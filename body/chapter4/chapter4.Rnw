% !TeX root = ./main.Rnw
%\SweaveUTF8

\chapter{Análisis de Resultados}

En el presente capítulo se realiza la descripción de los resultados obtenidos despues de la aplicación del método propuesto para la estrategia. De igual modo, se presentan los resultados arrojados por las pruebas de Backtesting simulando las entradas y salidas.

\section{Coeficientes del modelo}

<<echo=FALSE>>=
# library(tidyverse)
# library(magrittr)
# library(lubridate)
# library(gridExtra)
# library(TTR)
# library(caret)
# library(factoextra)
# library(purrr)
# library(PerformanceAnalytics)
# library(xtable)
# source('scripts/functions.R')
# 
# serie <- c('S&P_500', 'NASDAQ', 'NIKKEI_225', 'FTSE_100', 'BOVESPA')
# list_serie <- list()
# for(s in serie){
#   .aux_serie <- paste('data/', s, '.csv', sep = '') %>%
#     read_csv(locale = locale(decimal_mark = ",", grouping_mark = ".")) %>%
#     select(-one_of(c('Vol.', '% var.'))) %>%
#     mutate(Fecha = dmy(Fecha)) %>%
#     setNames(c('timestamp', 'close', 'open', 'high', 'low')) %>%
#     arrange(timestamp)
# 
#   list_serie %<>% rlist::list.append(.aux_serie)
# }
# 
# .tp <- 0.02
# .sl <- 0.025
# .h <- 20
.cut <- 0.5

list_cm <- list()
list_fr <- list()
list_model <- list()
for(i in 1:length(serie)){
  
  stock <- list_serie[[i]]
  
  # cm <- WFRegression(stock, .tp, .sl, .h, cut = .cut, uniqueBUYs = FALSE)
  cm <- WFRegression(stock, .tp, .sl, .h, cut = .cut, uniqueBUYs = FALSE)
  
  list_cm %<>% rlist::list.append(cm[[1]])
  
  list_model %<>% rlist::list.append(cm[[3]])
  
  prediction <- map_dfr(cm[[2]], as.data.frame) %>% setNames('predict')
  
  data <- stock %>% 
    predict_tp(.tp, .sl, .h) %>% 
    filter(year(timestamp) %in% seq(2013, 2019, 1)) %>% 
    na.omit()
  
  data %<>% cbind(prediction)
  
  long_all <- data %>% longStrat(tp = .tp, sl = .sl, horizon = .h) 
  long_result <- summStrat(long_all)
  
  list_fr %<>% rlist::list.append(long_result)
}
@

En la tabla 4.1 se describen los resultados de los parámetros arrojados por la regresión logística en los 6 períodos de entrenamiento para la serie del S\&P500.
\begin{center}
\captionof{table}{Resumen del modelo para cada período de entrenamiento utilizando S\&P500}
\captionof*{table}{Período de entrenamiento 2009 - 2012}
<<echo=FALSE, results=tex>>=
xtable(summary(list_model[[1]][[1]]))
@
\end{center}

\newpage
\begin{center}
\captionof*{table}{Período de entrenamiento 2009 - 2013}
<<echo=FALSE, results=tex>>=
xtable(summary(list_model[[1]][[2]]))
@
\end{center}
\begin{center}
\captionof*{table}{Período de entrenamiento 2009 - 2014}
<<echo=FALSE, results=tex>>=
xtable(summary(list_model[[1]][[3]]))
@
\end{center}
\begin{center}
\captionof*{table}{Período de entrenamiento 2009 - 2015}
<<echo=FALSE, results=tex>>=
xtable(summary(list_model[[1]][[4]]))
@
\end{center}
\newpage
\begin{center}
\captionof*{table}{Período de entrenamiento 2009 - 2016}
<<echo=FALSE, results=tex>>=
xtable(summary(list_model[[1]][[5]]))
@
\end{center}
\begin{center}
\captionof*{table}{Período de entrenamiento 2009 - 2017}
<<echo=FALSE, results=tex>>=
xtable(summary(list_model[[1]][[6]]))
@
\end{center}

Se observa que para todos los períodos el ACP arroja componentes que recogen el 85\% de la variación. También se aprecia que a medida que aumentamos los años de entrenamiento el número de p-valores menores que 0.05 aumentan, insinuando que mientras más observaciones para entrenar el modelo, mayor será la asociación entre los componentes y la capacidad de predecir el retorno objetivo.

\section{Resultados de la simulación}

<<echo=FALSE>>=
df_fr <- data.frame(nrow = 6)
for(i in 1:length(serie)){
  
  aux_buys <- list_fr[[i]][[2]] %>% 
    mutate(predictor = case_when(salida == 'Strategy' & buy_class == 'buy' ~ 'True Buy',
                                 TRUE ~ 'False Buy')) %>% 
    select('predictor') %>% 
    group_by(predictor) %>% 
    summarise(n = n()) %>% 
    setNames(c('metric', i)) %>%
    column_to_rownames(var = 'metric')
  
  aux_metric <- list_fr[[i]][[1]] %>%
    select(c('total_nro_trades', 'perc_predict', 'return_accum', 'max_drawdown')) %>% 
    mutate(perc_predict = perc_predict*100, 
           return_accum = return_accum*100,
           max_drawdown = max_drawdown*100) %>% 
    t() %>% 
    as.data.frame() %>% 
    setNames(i)
    
  aux_fr <- rbind(aux_buys, aux_metric)
  
  df_fr %<>% cbind(aux_fr)
  
}
df_fr[,1] <- NULL

df_fr %<>% setNames(serie) %>% 
  sapply(sprintf, fmt = c("%.0f", "%.0f", "%.0f", "%1.2f%%", "%1.2f%%", "%1.2f%%")) 

 rownames(df_fr) <- c('False Buys', 'True Buys', 'N° trades', 'Accuracy', 
                      'Accumulative Return', 'Max Drawdown')
@

En la tabla 4.2 se muestran los resultados de la simulación para cada uno de los índices. El número de trades cerrados es mayor en los indices BOVESPA y NIKKEI, lo que puede deberse a que estos mercados tuvieron una mayor volatilidad en el período de estudio. Por otra parte la predicción ronda entre 54\% al 62\%, dado que la relación pérdida/ganancia de los parámetros utilizados es $2.5/2 = 1.25$, es decir que por cada trade negativo se necesita 1.25 trades positivos para mitigar la pérdida. En este sentido una precisión del 60\% asegura un margen de ganancia, sin embargo, el retorno acumulado obtenido es pobre comparado con inversiones pasivas del mismo índice. 

\begin{center}
\captionof{table}{Resumen de resultados de aplicar el modelo en la data de prueba para los 5 índices}
<<echo=FALSE, results=tex>>=
xtable(df_fr, align = rep('c',6))
@
\end{center}
 
<<echo=FALSE>>=
list_trades_plot <- list()
for(i in 1:length(serie)){
  
  index <- case_when(i == 1 ~ 'S&P500',
                     i == 2 ~ 'NASDAQ',
                     i == 3 ~ 'NIKKEI_225',
                     i == 4 ~ 'FTSE_100',
                     i == 5 ~ 'BOVESPA')
  
  df_serie <- list_serie[[i]] %>% filter(year(timestamp) %in% seq(2013, 2019, 1)) %>% 
    mutate(ind = index) 
  
  aux_trades <- list_fr[[i]][[2]] %>% select(c('buy_date', 'salida')) 
  
  aux_join <- left_join(df_serie, aux_trades, by = c('timestamp' = 'buy_date')) %>% 
    select(c('timestamp', 'salida', 'ind'))
  
  list_trades_plot %<>% rlist::list.append(aux_join)
  
}

df_trades_plot <- map_dfr(list_trades_plot, as.data.frame) %>% 
  mutate(timestamp = as.POSIXct(timestamp))
@

En la figura 4.1 se observa los trades realizados por la simulación según el resultado de la operación, los trades verdes son aquellos clasificados como 'True buys' y resultaron en ganancia, los rojos, son clasificados como 'False buys' y resultaron en perdidas y los azules son clasificados como 'False buys' pero cerraron el trade por límite de tiempo.

\begin{figure}[H]
\setkeys{Gin}{height = .7\linewidth}
\centering
<<echo=FALSE, results=tex, fig=TRUE>>=
df_trades_plot %>% ggplot(aes(x = timestamp, y = ind, color = salida)) +
  geom_point(shape = '|', size = 8) +
  theme_minimal() +
  theme(legend.position = "none", axis.text.x = element_text(angle=45)) + 
  labs(x = NULL, y = NULL) +
  scale_color_manual(values=c('blue3', "red2", "green4")) +
  scale_x_datetime(breaks = "6 month",
                   date_labels = "%b-%y")
@
\caption{Clasificación de la simulación}
\end{figure}

Se observa como en la simulación utilizando el índice BOVESPA, los trades positivos aumentan su frecuencia a partir del segundo semestre del 2016, esto puede deberse al hecho de tener mayor número de observaciones para entrenar el modelo. Igualmente se aprecia como para el S\&P500 las operaciones se concentran en los primeros años de prueba, cerrando los demás años practicamente sin operaciones.

<<echo=FALSE>>=
list_return_plot <- list()
for(i in 1:length(serie)){
  
  index <- case_when(i == 1 ~ 'S&P500',
                     i == 2 ~ 'NASDAQ',
                     i == 3 ~ 'NIKKEI_225',
                     i == 4 ~ 'FTSE_100',
                     i == 5 ~ 'BOVESPA')
  
  aux_return_plot <- list_fr[[i]][[2]] %>% select(c('buy_date', 'returns'))
  
  aux_firstreturn <- data.frame(timestamp = c(dmy('01/01/2013'), as_date(aux_return_plot$buy_date)),
                                cap = c(0, cumsum(aux_return_plot$returns)),
                                index = index) %>% 
    mutate(timestamp = as.POSIXct(timestamp))
  
  list_return_plot %<>% rlist::list.append(aux_firstreturn)
  
}

df_return_plot <- map_dfr(list_return_plot, as.data.frame)
@

\begin{figure}[H]
\setkeys{Gin}{width = 1\textwidth}
\centering
<<echo=FALSE, results=tex, fig=TRUE>>=
df_return_plot %>%
  ggplot(aes(x = timestamp, color = index)) +
  geom_line(aes(y = cap)) +
  theme_minimal() +
  theme(legend.position = "top", axis.text.x = element_text(angle=45)) +
  labs(x = NULL, y = 'Retorno Acumulado') +
  scale_y_continuous(breaks = scales::pretty_breaks(), labels = scales::percent) +
  scale_x_datetime(date_breaks = "4 month", date_labels = "%b-%y")
@
\caption{Retorno acumulado para cada índice}
\end{figure}

Al asumir que siempre se abre la posición con la misma cantidad de dinero, en este caso 1000 USD, se sabe que los trades solo pueden arrojar dos resultados -0.02\% de ganancia en caso que sea positivo ó 0.025\% de pérdida en caso contrario, descartando las liquidaciones por límite de tiempo- En este sentido se aplica el contraste Wald–Wolfowitz comunmente llamado test de racha, para verificar la aleatoriedad de los resultados de los trades.

La prueba de Wald–Wolfowitz se puede definir de la siguiente manera:

\begin{itemize}
\item \textbf{H0}: La secuencia es producida de manera aleatoria.
\item \textbf{Hi}: La secuencia no es producida de manera aleatoria.
\end{itemize}

<<echo=FALSE>>=
list_runtest <- list_fr %>% map(function(x){
  
  x[[2]] %>% 
    select(c('sell_date', 'profits_ind')) %>% 
    filter(profits_ind %in% c(.tp*1000, -.sl*1000)) %>% 
    pull(profits_ind) %>%  
    factor() %>% 
    tseries::runs.test()
})
  table_runstest <- list_runtest %>% map_dfr(function(x)x[c('statistic', 'p.value')])
  row.names(table_runstest) <- serie
@
 
\begin{center}
\captionof{table}{Resultados del test de Wald–Wolfowitz (Test de Racha)}
<<echo=FALSE, results=tex>>=
xtable(table_runstest)
@
\end{center}

Frente a p-valores mayores a 0.05, y con un nivel de significación del 5\% no existen elementos suficientes para rechzar la hipótesis nula de aleatoriedad en la secuencia de los resultados de los trades, por lo que se puede concluir que los trades son independientes.
  
